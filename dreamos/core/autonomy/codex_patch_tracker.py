"""
Codex Patch Tracker
-----------------
Tracks and manages code patches generated by Codex.
"""

import logging
import json
import subprocess
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)

class CodexPatchTracker:
    """Tracks and manages code patches generated by Codex."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the patch tracker.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        self.patches: Dict[str, Dict[str, Any]] = {}  # patch_id -> patch_info
        self.logger = logger
        
        # Create failure log directory
        self.failure_log_dir = Path("runtime/scanner/codex_failures")
        self.failure_log_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize logging
        self.logger.info(
            "CodexPatchTracker initialized",
            extra={
                "platform": "codex",
                "status": "initialized",
                "tags": ["init", "patch_tracker"]
            }
        )
    
    def validate_with_scanner(self, patch_id: str, test_file: str) -> Tuple[bool, Dict[str, Any]]:
        """Validate a patch using the scanner.
        
        Args:
            patch_id: Unique identifier for the patch
            test_file: Path to the test file being patched
            
        Returns:
            Tuple of (is_valid, scanner_results)
        """
        try:
            # Run scanner with fail-on threshold
            result = subprocess.run(
                [
                    "python", "-m", "agent_tools.swarm_tools.scanner.scanner",
                    "--project-root", ".",
                    "--report", "json",
                    "--fail-on", "0"  # Block any duplicates
                ],
                capture_output=True,
                text=True
            )
            
            # Parse scanner results
            scanner_results = json.loads(result.stdout)
            
            # Check if scanner passed
            is_valid = result.returncode == 0
            
            # Log failure if any
            if not is_valid:
                failure_log = self.failure_log_dir / f"{patch_id}.json"
                with open(failure_log, "w") as f:
                    json.dump({
                        "patch_id": patch_id,
                        "test_file": test_file,
                        "timestamp": datetime.now().isoformat(),
                        "scanner_results": scanner_results
                    }, f, indent=2)
            
            return is_valid, scanner_results
            
        except Exception as e:
            self.logger.error(f"Scanner validation failed: {str(e)}")
            return False, {"error": str(e)}
    
    def track_patch(self, patch_id: str, test_file: str, outcome: str) -> None:
        """Track a patch attempt.
        
        Args:
            patch_id: Unique identifier for the patch
            test_file: Path to the test file being patched
            outcome: Result of the patch attempt
        """
        # Validate with scanner first
        is_valid, scanner_results = self.validate_with_scanner(patch_id, test_file)
        
        # Update outcome if scanner failed
        if not is_valid:
            outcome = "scanner_failed"
        
        self.patches[patch_id] = {
            "test_file": test_file,
            "outcome": outcome,
            "timestamp": datetime.now().isoformat(),
            "scanner_results": scanner_results
        }
        
        self.logger.info(
            f"Tracked patch {patch_id} for {test_file}",
            extra={
                "platform": "codex",
                "status": "tracked",
                "patch_id": patch_id,
                "test_file": test_file,
                "outcome": outcome,
                "scanner_valid": is_valid,
                "tags": ["track", "patch"]
            }
        )
    
    def get_patch_status(self, patch_id: str) -> Optional[Dict[str, Any]]:
        """Get status of a tracked patch.
        
        Args:
            patch_id: ID of the patch to check
            
        Returns:
            Patch status info if found, None otherwise
        """
        return self.patches.get(patch_id)
    
    def get_all_patches(self) -> Dict[str, Dict[str, Any]]:
        """Get all tracked patches.
        
        Returns:
            Dictionary of all tracked patches
        """
        return self.patches.copy() 
