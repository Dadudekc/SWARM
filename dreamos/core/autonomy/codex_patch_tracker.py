"""
Codex Patch Tracker
-----------------
Tracks and manages code patches generated by Codex.
"""

import logging
import json
import subprocess
import os
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path
from datetime import datetime
from agent_tools.swarm_tools.scanner.scanner import Scanner, ScanResults

from .base_tracker import BaseTracker

class CodexPatchTracker(BaseTracker):
    """Tracks and manages code patches generated by Codex."""
    
    def __init__(self, failure_log_dir: Optional[str] = None):
        """Initialize the patch tracker.
        
        Args:
            failure_log_dir: Directory to store failure logs. Defaults to runtime/scanner/codex_failures/
        """
        super().__init__(
            log_dir=failure_log_dir or "runtime/scanner/codex_failures",
            platform="codex",
            tracker_type="patch_tracker"
        )
        self.scanner = Scanner(str(Path.cwd()))
        self.patches: Dict[str, Dict[str, Any]] = {}  # patch_id -> patch_info
    
    async def validate_with_scanner(self, patch_id: str, file_path: str) -> Tuple[bool, Dict[str, Any]]:
        """Validate a patch using the scanner.
        
        Args:
            patch_id: Unique identifier for the patch
            file_path: Path to the file being patched
            
        Returns:
            Tuple of (is_valid, results)
        """
        try:
            # Run scanner on the project
            results = await self.scanner.scan_project()
            
            # Check if the patched file has duplicates
            file_duplicates = [
                item for category in results.duplicates.values()
                for item in category
                if item['file'] == file_path
            ]
            
            if file_duplicates:
                # Log the failure
                self._log_failure(
                    patch_id,
                    {
                        "file": file_path,
                        "scanner_results": results.summary(),
                        "duplicates": file_duplicates
                    },
                    "scanner_validation_failed"
                )
                return False, results.summary()
            
            return True, results.summary()
            
        except Exception as e:
            self.logger.error(f"Scanner validation failed: {str(e)}")
            self._log_failure(
                patch_id,
                {"file": file_path, "error": str(e)},
                "scanner_error"
            )
            return False, {"error": str(e)}
    
    async def track_patch(self, patch_id: str, file_path: str, outcome: str) -> None:
        """Track a patch with its outcome.
        
        Args:
            patch_id: Unique identifier for the patch
            file_path: Path to the file being patched
            outcome: Outcome of the patch (success, failure, scanner_failed)
        """
        # Validate with scanner first
        is_valid, scanner_results = await self.validate_with_scanner(patch_id, file_path)
        
        # Update outcome if scanner validation failed
        if not is_valid and outcome == "success":
            outcome = "scanner_failed"
        
        # Store patch metadata
        self.patches[patch_id] = {
            "file": file_path,
            "outcome": outcome,
            "timestamp": datetime.now().isoformat(),
            "scanner_results": scanner_results
        }
        
        # Log the outcome
        if outcome == "success":
            self._log_success(
                patch_id,
                {
                    "file": file_path,
                    "scanner_valid": is_valid,
                    "scanner_results": scanner_results
                },
                "patch_success"
            )
        else:
            self._log_failure(
                patch_id,
                {
                    "file": file_path,
                    "outcome": outcome,
                    "scanner_valid": is_valid,
                    "scanner_results": scanner_results
                },
                "patch_failure"
            )
    
    def get_patch_status(self, patch_id: str) -> Optional[Dict[str, Any]]:
        """Get the status of a patch.
        
        Args:
            patch_id: Unique identifier for the patch
            
        Returns:
            Patch metadata if found, None otherwise
        """
        return self.patches.get(patch_id)
    
    def get_all_patches(self) -> Dict[str, Dict[str, Any]]:
        """Get all tracked patches.
        
        Returns:
            Dictionary of all patch metadata
        """
        return self.patches.copy() 
